"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/GameCanvas.tsx":
/*!***************************************!*\
  !*** ./src/components/GameCanvas.tsx ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GameCanvas)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction GameCanvas(param) {\n    let { playerName } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [gameLoop, setGameLoop] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [player, setPlayer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0,\n        width: 50,\n        height: 50,\n        speed: 5,\n        name: playerName,\n        score: 0,\n        bullets: []\n    });\n    const [enemies, setEnemies] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [keys, setKeys] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isGameOver, setIsGameOver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Check collision between two objects\n    const checkCollision = (obj1, obj2)=>{\n        return obj1.x < obj2.x + obj2.width && obj1.x + obj1.width > obj2.x && obj1.y < obj2.y + obj2.height && obj1.y + obj1.height > obj2.y;\n    };\n    // Initialize game\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"GameCanvas.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            // Set canvas size\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            // Center player initially\n            setPlayer({\n                \"GameCanvas.useEffect\": (prev)=>({\n                        ...prev,\n                        x: canvas.width / 2 - 25,\n                        y: canvas.height - 100\n                    })\n            }[\"GameCanvas.useEffect\"]);\n            // Handle keyboard input\n            const handleKeyDown = {\n                \"GameCanvas.useEffect.handleKeyDown\": (e)=>{\n                    setKeys({\n                        \"GameCanvas.useEffect.handleKeyDown\": (prev)=>({\n                                ...prev,\n                                [e.key]: true\n                            })\n                    }[\"GameCanvas.useEffect.handleKeyDown\"]);\n                    if (e.key === ' ') {\n                        shoot();\n                    }\n                    // Reset game on Enter if game over\n                    if (e.key === 'Enter' && isGameOver) {\n                        resetGame();\n                    }\n                }\n            }[\"GameCanvas.useEffect.handleKeyDown\"];\n            const handleKeyUp = {\n                \"GameCanvas.useEffect.handleKeyUp\": (e)=>{\n                    setKeys({\n                        \"GameCanvas.useEffect.handleKeyUp\": (prev)=>({\n                                ...prev,\n                                [e.key]: false\n                            })\n                    }[\"GameCanvas.useEffect.handleKeyUp\"]);\n                }\n            }[\"GameCanvas.useEffect.handleKeyUp\"];\n            window.addEventListener('keydown', handleKeyDown);\n            window.addEventListener('keyup', handleKeyUp);\n            // Start game loop\n            const loop = window.requestAnimationFrame(gameUpdate);\n            setGameLoop(loop);\n            // Cleanup\n            return ({\n                \"GameCanvas.useEffect\": ()=>{\n                    window.removeEventListener('keydown', handleKeyDown);\n                    window.removeEventListener('keyup', handleKeyUp);\n                    if (gameLoop) window.cancelAnimationFrame(gameLoop);\n                }\n            })[\"GameCanvas.useEffect\"];\n        }\n    }[\"GameCanvas.useEffect\"], [\n        isGameOver\n    ]);\n    // Reset game state\n    const resetGame = ()=>{\n        setIsGameOver(false);\n        setPlayer((prev)=>({\n                ...prev,\n                score: 0,\n                bullets: [],\n                x: window.innerWidth / 2 - 25,\n                y: window.innerHeight - 100\n            }));\n        setEnemies([]);\n    };\n    // Game update function\n    const gameUpdate = ()=>{\n        const canvas = canvasRef.current;\n        if (!canvas || isGameOver) return;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) return;\n        // Clear canvas\n        ctx.fillStyle = 'black';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Update game objects\n        updatePlayer();\n        updateBullets();\n        updateEnemies();\n        // Draw everything\n        drawGame(ctx);\n        // Continue game loop\n        window.requestAnimationFrame(gameUpdate);\n    };\n    // Update player position\n    const updatePlayer = ()=>{\n        if (isGameOver) return;\n        setPlayer((prev)=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return prev;\n            let newX = prev.x;\n            let newY = prev.y;\n            if (keys['ArrowLeft'] || keys['a']) newX -= prev.speed;\n            if (keys['ArrowRight'] || keys['d']) newX += prev.speed;\n            if (keys['ArrowUp'] || keys['w']) newY -= prev.speed;\n            if (keys['ArrowDown'] || keys['s']) newY += prev.speed;\n            // Keep player within bounds\n            newX = Math.max(0, Math.min(canvas.width - prev.width, newX));\n            newY = Math.max(0, Math.min(canvas.height - prev.height, newY));\n            return {\n                ...prev,\n                x: newX,\n                y: newY\n            };\n        });\n    };\n    // Shoot bullet\n    const shoot = ()=>{\n        if (isGameOver) return;\n        setPlayer((prev)=>({\n                ...prev,\n                bullets: [\n                    ...prev.bullets,\n                    {\n                        x: prev.x + prev.width / 2 - 2.5,\n                        y: prev.y,\n                        width: 5,\n                        height: 10,\n                        speed: 10,\n                        active: true\n                    }\n                ]\n            }));\n    };\n    // Update bullets and check collisions\n    const updateBullets = ()=>{\n        if (isGameOver) return;\n        setPlayer((prev)=>{\n            const updatedBullets = prev.bullets.map((bullet)=>({\n                    ...bullet,\n                    y: bullet.y - bullet.speed\n                })).filter((bullet)=>{\n                // Check collision with enemies\n                let hasCollided = false;\n                setEnemies((enemies)=>{\n                    const updatedEnemies = enemies.filter((enemy)=>{\n                        if (!hasCollided && checkCollision(bullet, enemy)) {\n                            hasCollided = true;\n                            // Update score when enemy is hit\n                            setPlayer((p)=>({\n                                    ...p,\n                                    score: p.score + 10\n                                }));\n                            return false // Remove the enemy\n                            ;\n                        }\n                        return true;\n                    });\n                    return updatedEnemies;\n                });\n                // Keep bullets that haven't collided and are still on screen\n                return !hasCollided && bullet.y > -bullet.height;\n            });\n            return {\n                ...prev,\n                bullets: updatedBullets\n            };\n        });\n    };\n    // Spawn enemies\n    const spawnEnemy = ()=>{\n        if (isGameOver) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const enemy = {\n            x: Math.random() * (canvas.width - 40),\n            y: -50,\n            width: 40,\n            height: 40,\n            speed: 2 + Math.floor(player.score / 100) * 0.5,\n            health: 1\n        };\n        setEnemies((prev)=>[\n                ...prev,\n                enemy\n            ]);\n    };\n    // Update enemies with improved movement\n    const updateEnemies = ()=>{\n        if (isGameOver) return;\n        // Spawn new enemy with increasing frequency based on score\n        const spawnChance = Math.min(0.02 + player.score / 5000, 0.1);\n        if (Math.random() < spawnChance) {\n            spawnEnemy();\n        }\n        setEnemies((prev)=>prev.map((enemy)=>{\n                // Add slight horizontal movement\n                const dx = Math.sin(Date.now() / 1000 + enemy.x) * 2;\n                return {\n                    ...enemy,\n                    x: Math.max(0, Math.min(window.innerWidth - enemy.width, enemy.x + dx)),\n                    y: enemy.y + enemy.speed\n                };\n            }).filter((enemy)=>{\n                // Check collision with player\n                if (checkCollision(enemy, player)) {\n                    setIsGameOver(true);\n                    return false;\n                }\n                return enemy.y < window.innerHeight;\n            }));\n    };\n    // Draw game objects\n    const drawGame = (ctx)=>{\n        // Draw player\n        ctx.fillStyle = '#00ff00';\n        ctx.fillRect(player.x, player.y, player.width, player.height);\n        // Draw bullets\n        ctx.fillStyle = '#ffff00';\n        player.bullets.forEach((bullet)=>{\n            ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);\n        });\n        // Draw enemies\n        ctx.fillStyle = '#ff0000';\n        enemies.forEach((enemy)=>{\n            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);\n        });\n        // Draw score\n        ctx.fillStyle = 'white';\n        ctx.font = '20px Arial';\n        ctx.fillText(\"Score: \".concat(player.score), 10, 30);\n        // Draw game over screen\n        if (isGameOver) {\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.font = '48px Arial';\n            ctx.textAlign = 'center';\n            ctx.fillText('Game Over!', ctx.canvas.width / 2, ctx.canvas.height / 2 - 50);\n            ctx.font = '24px Arial';\n            ctx.fillText(\"Final Score: \".concat(player.score), ctx.canvas.width / 2, ctx.canvas.height / 2);\n            ctx.fillText('Press Enter to Play Again', ctx.canvas.width / 2, ctx.canvas.height / 2 + 50);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"w-full h-full bg-black\"\n    }, void 0, false, {\n        fileName: \"/project/sandbox/user-workspace/src/components/GameCanvas.tsx\",\n        lineNumber: 313,\n        columnNumber: 5\n    }, this);\n}\n_s(GameCanvas, \"bLLYx5P3lff7ekbt6gROwAgkaFg=\");\n_c = GameCanvas;\nvar _c;\n$RefreshReg$(_c, \"GameCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0dhbWVDYW52YXMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVtRDtBQTRCcEMsU0FBU0csV0FBVyxLQUErQjtRQUEvQixFQUFFQyxVQUFVLEVBQW1CLEdBQS9COztJQUNqQyxNQUFNQyxZQUFZSiw2Q0FBTUEsQ0FBb0I7SUFDNUMsTUFBTSxDQUFDSyxVQUFVQyxZQUFZLEdBQUdMLCtDQUFRQTtJQUN4QyxNQUFNLENBQUNNLFFBQVFDLFVBQVUsR0FBR1AsK0NBQVFBLENBQVM7UUFDM0NRLEdBQUc7UUFDSEMsR0FBRztRQUNIQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsT0FBTztRQUNQQyxNQUFNWDtRQUNOWSxPQUFPO1FBQ1BDLFNBQVMsRUFBRTtJQUNiO0lBQ0EsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdqQiwrQ0FBUUEsQ0FBVSxFQUFFO0lBQ2xELE1BQU0sQ0FBQ2tCLE1BQU1DLFFBQVEsR0FBR25CLCtDQUFRQSxDQUE2QixDQUFDO0lBQzlELE1BQU0sQ0FBQ29CLFlBQVlDLGNBQWMsR0FBR3JCLCtDQUFRQSxDQUFDO0lBRTdDLHNDQUFzQztJQUN0QyxNQUFNc0IsaUJBQWlCLENBQUNDLE1BQWtCQztRQUN4QyxPQUNFRCxLQUFLZixDQUFDLEdBQUdnQixLQUFLaEIsQ0FBQyxHQUFHZ0IsS0FBS2QsS0FBSyxJQUM1QmEsS0FBS2YsQ0FBQyxHQUFHZSxLQUFLYixLQUFLLEdBQUdjLEtBQUtoQixDQUFDLElBQzVCZSxLQUFLZCxDQUFDLEdBQUdlLEtBQUtmLENBQUMsR0FBR2UsS0FBS2IsTUFBTSxJQUM3QlksS0FBS2QsQ0FBQyxHQUFHYyxLQUFLWixNQUFNLEdBQUdhLEtBQUtmLENBQUM7SUFFakM7SUFFQSxrQkFBa0I7SUFDbEJYLGdEQUFTQTtnQ0FBQztZQUNSLE1BQU0yQixTQUFTdEIsVUFBVXVCLE9BQU87WUFDaEMsSUFBSSxDQUFDRCxRQUFRO1lBRWIsa0JBQWtCO1lBQ2xCQSxP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L3NyYy9jb21wb25lbnRzL0dhbWVDYW52YXMudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuXG5pbnRlcmZhY2UgR2FtZUNhbnZhc1Byb3BzIHtcbiAgcGxheWVyTmFtZTogc3RyaW5nXG59XG5cbmludGVyZmFjZSBHYW1lT2JqZWN0IHtcbiAgeDogbnVtYmVyXG4gIHk6IG51bWJlclxuICB3aWR0aDogbnVtYmVyXG4gIGhlaWdodDogbnVtYmVyXG4gIHNwZWVkOiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIFBsYXllciBleHRlbmRzIEdhbWVPYmplY3Qge1xuICBuYW1lOiBzdHJpbmdcbiAgc2NvcmU6IG51bWJlclxuICBidWxsZXRzOiBCdWxsZXRbXVxufVxuXG5pbnRlcmZhY2UgRW5lbXkgZXh0ZW5kcyBHYW1lT2JqZWN0IHtcbiAgaGVhbHRoOiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIEJ1bGxldCBleHRlbmRzIEdhbWVPYmplY3Qge1xuICBhY3RpdmU6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gR2FtZUNhbnZhcyh7IHBsYXllck5hbWUgfTogR2FtZUNhbnZhc1Byb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbClcbiAgY29uc3QgW2dhbWVMb29wLCBzZXRHYW1lTG9vcF0gPSB1c2VTdGF0ZTxudW1iZXI+KClcbiAgY29uc3QgW3BsYXllciwgc2V0UGxheWVyXSA9IHVzZVN0YXRlPFBsYXllcj4oe1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogNTAsXG4gICAgaGVpZ2h0OiA1MCxcbiAgICBzcGVlZDogNSxcbiAgICBuYW1lOiBwbGF5ZXJOYW1lLFxuICAgIHNjb3JlOiAwLFxuICAgIGJ1bGxldHM6IFtdXG4gIH0pXG4gIGNvbnN0IFtlbmVtaWVzLCBzZXRFbmVtaWVzXSA9IHVzZVN0YXRlPEVuZW15W10+KFtdKVxuICBjb25zdCBba2V5cywgc2V0S2V5c10gPSB1c2VTdGF0ZTx7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfT4oe30pXG4gIGNvbnN0IFtpc0dhbWVPdmVyLCBzZXRJc0dhbWVPdmVyXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIC8vIENoZWNrIGNvbGxpc2lvbiBiZXR3ZWVuIHR3byBvYmplY3RzXG4gIGNvbnN0IGNoZWNrQ29sbGlzaW9uID0gKG9iajE6IEdhbWVPYmplY3QsIG9iajI6IEdhbWVPYmplY3QpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqMS54IDwgb2JqMi54ICsgb2JqMi53aWR0aCAmJlxuICAgICAgb2JqMS54ICsgb2JqMS53aWR0aCA+IG9iajIueCAmJlxuICAgICAgb2JqMS55IDwgb2JqMi55ICsgb2JqMi5oZWlnaHQgJiZcbiAgICAgIG9iajEueSArIG9iajEuaGVpZ2h0ID4gb2JqMi55XG4gICAgKVxuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBnYW1lXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICAvLyBTZXQgY2FudmFzIHNpemVcbiAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcblxuICAgIC8vIENlbnRlciBwbGF5ZXIgaW5pdGlhbGx5XG4gICAgc2V0UGxheWVyKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICB4OiBjYW52YXMud2lkdGggLyAyIC0gMjUsXG4gICAgICB5OiBjYW52YXMuaGVpZ2h0IC0gMTAwXG4gICAgfSkpXG5cbiAgICAvLyBIYW5kbGUga2V5Ym9hcmQgaW5wdXRcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgIHNldEtleXMocHJldiA9PiAoeyAuLi5wcmV2LCBbZS5rZXldOiB0cnVlIH0pKVxuICAgICAgaWYgKGUua2V5ID09PSAnICcpIHsgLy8gU3BhY2ViYXIgdG8gc2hvb3RcbiAgICAgICAgc2hvb3QoKVxuICAgICAgfVxuICAgICAgLy8gUmVzZXQgZ2FtZSBvbiBFbnRlciBpZiBnYW1lIG92ZXJcbiAgICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJyAmJiBpc0dhbWVPdmVyKSB7XG4gICAgICAgIHJlc2V0R2FtZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlS2V5VXAgPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgc2V0S2V5cyhwcmV2ID0+ICh7IC4uLnByZXYsIFtlLmtleV06IGZhbHNlIH0pKVxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVLZXlVcClcblxuICAgIC8vIFN0YXJ0IGdhbWUgbG9vcFxuICAgIGNvbnN0IGxvb3AgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGdhbWVVcGRhdGUpXG4gICAgc2V0R2FtZUxvb3AobG9vcClcblxuICAgIC8vIENsZWFudXBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlS2V5VXApXG4gICAgICBpZiAoZ2FtZUxvb3ApIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShnYW1lTG9vcClcbiAgICB9XG4gIH0sIFtpc0dhbWVPdmVyXSlcblxuICAvLyBSZXNldCBnYW1lIHN0YXRlXG4gIGNvbnN0IHJlc2V0R2FtZSA9ICgpID0+IHtcbiAgICBzZXRJc0dhbWVPdmVyKGZhbHNlKVxuICAgIHNldFBsYXllcihwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgc2NvcmU6IDAsXG4gICAgICBidWxsZXRzOiBbXSxcbiAgICAgIHg6IHdpbmRvdy5pbm5lcldpZHRoIC8gMiAtIDI1LFxuICAgICAgeTogd2luZG93LmlubmVySGVpZ2h0IC0gMTAwXG4gICAgfSkpXG4gICAgc2V0RW5lbWllcyhbXSlcbiAgfVxuXG4gIC8vIEdhbWUgdXBkYXRlIGZ1bmN0aW9uXG4gIGNvbnN0IGdhbWVVcGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcyB8fCBpc0dhbWVPdmVyKSByZXR1cm5cblxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgaWYgKCFjdHgpIHJldHVyblxuXG4gICAgLy8gQ2xlYXIgY2FudmFzXG4gICAgY3R4LmZpbGxTdHlsZSA9ICdibGFjaydcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgLy8gVXBkYXRlIGdhbWUgb2JqZWN0c1xuICAgIHVwZGF0ZVBsYXllcigpXG4gICAgdXBkYXRlQnVsbGV0cygpXG4gICAgdXBkYXRlRW5lbWllcygpXG5cbiAgICAvLyBEcmF3IGV2ZXJ5dGhpbmdcbiAgICBkcmF3R2FtZShjdHgpXG5cbiAgICAvLyBDb250aW51ZSBnYW1lIGxvb3BcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGdhbWVVcGRhdGUpXG4gIH1cblxuICAvLyBVcGRhdGUgcGxheWVyIHBvc2l0aW9uXG4gIGNvbnN0IHVwZGF0ZVBsYXllciA9ICgpID0+IHtcbiAgICBpZiAoaXNHYW1lT3ZlcikgcmV0dXJuXG5cbiAgICBzZXRQbGF5ZXIocHJldiA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudFxuICAgICAgaWYgKCFjYW52YXMpIHJldHVybiBwcmV2XG5cbiAgICAgIGxldCBuZXdYID0gcHJldi54XG4gICAgICBsZXQgbmV3WSA9IHByZXYueVxuXG4gICAgICBpZiAoa2V5c1snQXJyb3dMZWZ0J10gfHwga2V5c1snYSddKSBuZXdYIC09IHByZXYuc3BlZWRcbiAgICAgIGlmIChrZXlzWydBcnJvd1JpZ2h0J10gfHwga2V5c1snZCddKSBuZXdYICs9IHByZXYuc3BlZWRcbiAgICAgIGlmIChrZXlzWydBcnJvd1VwJ10gfHwga2V5c1sndyddKSBuZXdZIC09IHByZXYuc3BlZWRcbiAgICAgIGlmIChrZXlzWydBcnJvd0Rvd24nXSB8fCBrZXlzWydzJ10pIG5ld1kgKz0gcHJldi5zcGVlZFxuXG4gICAgICAvLyBLZWVwIHBsYXllciB3aXRoaW4gYm91bmRzXG4gICAgICBuZXdYID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY2FudmFzLndpZHRoIC0gcHJldi53aWR0aCwgbmV3WCkpXG4gICAgICBuZXdZID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY2FudmFzLmhlaWdodCAtIHByZXYuaGVpZ2h0LCBuZXdZKSlcblxuICAgICAgcmV0dXJuIHsgLi4ucHJldiwgeDogbmV3WCwgeTogbmV3WSB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIFNob290IGJ1bGxldFxuICBjb25zdCBzaG9vdCA9ICgpID0+IHtcbiAgICBpZiAoaXNHYW1lT3ZlcikgcmV0dXJuXG5cbiAgICBzZXRQbGF5ZXIocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGJ1bGxldHM6IFsuLi5wcmV2LmJ1bGxldHMsIHtcbiAgICAgICAgeDogcHJldi54ICsgcHJldi53aWR0aCAvIDIgLSAyLjUsXG4gICAgICAgIHk6IHByZXYueSxcbiAgICAgICAgd2lkdGg6IDUsXG4gICAgICAgIGhlaWdodDogMTAsXG4gICAgICAgIHNwZWVkOiAxMCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XVxuICAgIH0pKVxuICB9XG5cbiAgLy8gVXBkYXRlIGJ1bGxldHMgYW5kIGNoZWNrIGNvbGxpc2lvbnNcbiAgY29uc3QgdXBkYXRlQnVsbGV0cyA9ICgpID0+IHtcbiAgICBpZiAoaXNHYW1lT3ZlcikgcmV0dXJuXG5cbiAgICBzZXRQbGF5ZXIocHJldiA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkQnVsbGV0cyA9IHByZXYuYnVsbGV0c1xuICAgICAgICAubWFwKGJ1bGxldCA9PiAoe1xuICAgICAgICAgIC4uLmJ1bGxldCxcbiAgICAgICAgICB5OiBidWxsZXQueSAtIGJ1bGxldC5zcGVlZFxuICAgICAgICB9KSlcbiAgICAgICAgLmZpbHRlcihidWxsZXQgPT4ge1xuICAgICAgICAgIC8vIENoZWNrIGNvbGxpc2lvbiB3aXRoIGVuZW1pZXNcbiAgICAgICAgICBsZXQgaGFzQ29sbGlkZWQgPSBmYWxzZVxuICAgICAgICAgIHNldEVuZW1pZXMoZW5lbWllcyA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRW5lbWllcyA9IGVuZW1pZXMuZmlsdGVyKGVuZW15ID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNDb2xsaWRlZCAmJiBjaGVja0NvbGxpc2lvbihidWxsZXQsIGVuZW15KSkge1xuICAgICAgICAgICAgICAgIGhhc0NvbGxpZGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzY29yZSB3aGVuIGVuZW15IGlzIGhpdFxuICAgICAgICAgICAgICAgIHNldFBsYXllcihwID0+ICh7XG4gICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgc2NvcmU6IHAuc2NvcmUgKyAxMFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZSAvLyBSZW1vdmUgdGhlIGVuZW15XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZEVuZW1pZXNcbiAgICAgICAgICB9KVxuICAgICAgICAgIC8vIEtlZXAgYnVsbGV0cyB0aGF0IGhhdmVuJ3QgY29sbGlkZWQgYW5kIGFyZSBzdGlsbCBvbiBzY3JlZW5cbiAgICAgICAgICByZXR1cm4gIWhhc0NvbGxpZGVkICYmIGJ1bGxldC55ID4gLWJ1bGxldC5oZWlnaHRcbiAgICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgYnVsbGV0czogdXBkYXRlZEJ1bGxldHNcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gU3Bhd24gZW5lbWllc1xuICBjb25zdCBzcGF3bkVuZW15ID0gKCkgPT4ge1xuICAgIGlmIChpc0dhbWVPdmVyKSByZXR1cm5cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgZW5lbXk6IEVuZW15ID0ge1xuICAgICAgeDogTWF0aC5yYW5kb20oKSAqIChjYW52YXMud2lkdGggLSA0MCksXG4gICAgICB5OiAtNTAsXG4gICAgICB3aWR0aDogNDAsXG4gICAgICBoZWlnaHQ6IDQwLFxuICAgICAgc3BlZWQ6IDIgKyBNYXRoLmZsb29yKHBsYXllci5zY29yZSAvIDEwMCkgKiAwLjUsIC8vIEluY3JlYXNlIHNwZWVkIHdpdGggc2NvcmVcbiAgICAgIGhlYWx0aDogMVxuICAgIH1cblxuICAgIHNldEVuZW1pZXMocHJldiA9PiBbLi4ucHJldiwgZW5lbXldKVxuICB9XG5cbiAgLy8gVXBkYXRlIGVuZW1pZXMgd2l0aCBpbXByb3ZlZCBtb3ZlbWVudFxuICBjb25zdCB1cGRhdGVFbmVtaWVzID0gKCkgPT4ge1xuICAgIGlmIChpc0dhbWVPdmVyKSByZXR1cm5cblxuICAgIC8vIFNwYXduIG5ldyBlbmVteSB3aXRoIGluY3JlYXNpbmcgZnJlcXVlbmN5IGJhc2VkIG9uIHNjb3JlXG4gICAgY29uc3Qgc3Bhd25DaGFuY2UgPSBNYXRoLm1pbigwLjAyICsgcGxheWVyLnNjb3JlIC8gNTAwMCwgMC4xKVxuICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgc3Bhd25DaGFuY2UpIHtcbiAgICAgIHNwYXduRW5lbXkoKVxuICAgIH1cblxuICAgIHNldEVuZW1pZXMocHJldiA9PiBcbiAgICAgIHByZXZcbiAgICAgICAgLm1hcChlbmVteSA9PiB7XG4gICAgICAgICAgLy8gQWRkIHNsaWdodCBob3Jpem9udGFsIG1vdmVtZW50XG4gICAgICAgICAgY29uc3QgZHggPSBNYXRoLnNpbihEYXRlLm5vdygpIC8gMTAwMCArIGVuZW15LngpICogMlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5lbmVteSxcbiAgICAgICAgICAgIHg6IE1hdGgubWF4KDAsIE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoIC0gZW5lbXkud2lkdGgsIGVuZW15LnggKyBkeCkpLFxuICAgICAgICAgICAgeTogZW5lbXkueSArIGVuZW15LnNwZWVkXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKGVuZW15ID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICAgICAgICBpZiAoY2hlY2tDb2xsaXNpb24oZW5lbXksIHBsYXllcikpIHtcbiAgICAgICAgICAgIHNldElzR2FtZU92ZXIodHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZW5lbXkueSA8IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICB9KVxuICAgIClcbiAgfVxuXG4gIC8vIERyYXcgZ2FtZSBvYmplY3RzXG4gIGNvbnN0IGRyYXdHYW1lID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSA9PiB7XG4gICAgLy8gRHJhdyBwbGF5ZXJcbiAgICBjdHguZmlsbFN0eWxlID0gJyMwMGZmMDAnXG4gICAgY3R4LmZpbGxSZWN0KHBsYXllci54LCBwbGF5ZXIueSwgcGxheWVyLndpZHRoLCBwbGF5ZXIuaGVpZ2h0KVxuXG4gICAgLy8gRHJhdyBidWxsZXRzXG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZmZjAwJ1xuICAgIHBsYXllci5idWxsZXRzLmZvckVhY2goYnVsbGV0ID0+IHtcbiAgICAgIGN0eC5maWxsUmVjdChidWxsZXQueCwgYnVsbGV0LnksIGJ1bGxldC53aWR0aCwgYnVsbGV0LmhlaWdodClcbiAgICB9KVxuXG4gICAgLy8gRHJhdyBlbmVtaWVzXG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjZmYwMDAwJ1xuICAgIGVuZW1pZXMuZm9yRWFjaChlbmVteSA9PiB7XG4gICAgICBjdHguZmlsbFJlY3QoZW5lbXkueCwgZW5lbXkueSwgZW5lbXkud2lkdGgsIGVuZW15LmhlaWdodClcbiAgICB9KVxuXG4gICAgLy8gRHJhdyBzY29yZVxuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnXG4gICAgY3R4LmZvbnQgPSAnMjBweCBBcmlhbCdcbiAgICBjdHguZmlsbFRleHQoYFNjb3JlOiAke3BsYXllci5zY29yZX1gLCAxMCwgMzApXG5cbiAgICAvLyBEcmF3IGdhbWUgb3ZlciBzY3JlZW5cbiAgICBpZiAoaXNHYW1lT3Zlcikge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDAuNyknXG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpXG4gICAgICBcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnXG4gICAgICBjdHguZm9udCA9ICc0OHB4IEFyaWFsJ1xuICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInXG4gICAgICBjdHguZmlsbFRleHQoJ0dhbWUgT3ZlciEnLCBjdHguY2FudmFzLndpZHRoIC8gMiwgY3R4LmNhbnZhcy5oZWlnaHQgLyAyIC0gNTApXG4gICAgICBcbiAgICAgIGN0eC5mb250ID0gJzI0cHggQXJpYWwnXG4gICAgICBjdHguZmlsbFRleHQoYEZpbmFsIFNjb3JlOiAke3BsYXllci5zY29yZX1gLCBjdHguY2FudmFzLndpZHRoIC8gMiwgY3R4LmNhbnZhcy5oZWlnaHQgLyAyKVxuICAgICAgY3R4LmZpbGxUZXh0KCdQcmVzcyBFbnRlciB0byBQbGF5IEFnYWluJywgY3R4LmNhbnZhcy53aWR0aCAvIDIsIGN0eC5jYW52YXMuaGVpZ2h0IC8gMiArIDUwKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGNhbnZhcyBcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBiZy1ibGFja1wiXG4gICAgLz5cbiAgKVxufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiR2FtZUNhbnZhcyIsInBsYXllck5hbWUiLCJjYW52YXNSZWYiLCJnYW1lTG9vcCIsInNldEdhbWVMb29wIiwicGxheWVyIiwic2V0UGxheWVyIiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInNwZWVkIiwibmFtZSIsInNjb3JlIiwiYnVsbGV0cyIsImVuZW1pZXMiLCJzZXRFbmVtaWVzIiwia2V5cyIsInNldEtleXMiLCJpc0dhbWVPdmVyIiwic2V0SXNHYW1lT3ZlciIsImNoZWNrQ29sbGlzaW9uIiwib2JqMSIsIm9iajIiLCJjYW52YXMiLCJjdXJyZW50Iiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwicHJldiIsImhhbmRsZUtleURvd24iLCJlIiwia2V5Iiwic2hvb3QiLCJyZXNldEdhbWUiLCJoYW5kbGVLZXlVcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJsb29wIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZ2FtZVVwZGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImN0eCIsImdldENvbnRleHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInVwZGF0ZVBsYXllciIsInVwZGF0ZUJ1bGxldHMiLCJ1cGRhdGVFbmVtaWVzIiwiZHJhd0dhbWUiLCJuZXdYIiwibmV3WSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJhY3RpdmUiLCJ1cGRhdGVkQnVsbGV0cyIsIm1hcCIsImJ1bGxldCIsImZpbHRlciIsImhhc0NvbGxpZGVkIiwidXBkYXRlZEVuZW1pZXMiLCJlbmVteSIsInAiLCJzcGF3bkVuZW15IiwicmFuZG9tIiwiZmxvb3IiLCJoZWFsdGgiLCJzcGF3bkNoYW5jZSIsImR4Iiwic2luIiwiRGF0ZSIsIm5vdyIsImZvckVhY2giLCJmb250IiwiZmlsbFRleHQiLCJ0ZXh0QWxpZ24iLCJyZWYiLCJjbGFzc05hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/GameCanvas.tsx\n"));

/***/ })

});